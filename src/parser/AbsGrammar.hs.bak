

module AbsGrammar where

-- Haskell module generated by the BNF converter




newtype Ident = Ident String deriving (Eq, Ord, Show, Read)
data Prog = Program [Decl]
  deriving (Eq, Ord, Show, Read)

data Lit = LitInt Integer | LitTrue | LitFalse | LitList [Expr]
  deriving (Eq, Ord, Show, Read)

data Expr
    = EVar Ident
    | ELit Lit
    | EApp Expr Expr
    | Neg Expr
    | Not Expr
    | ECons Expr Expr
    | EMul Expr MulOp Expr
    | EAdd Expr AddOp Expr
    | ERel Expr RelOp Expr
    | EAnd Expr Expr
    | EOr Expr Expr
    | Lambda Bind Expr
    | Let [Decl] Expr
    | Case Expr [EAlt]
    | If Expr Expr Expr
  deriving (Eq, Ord, Show, Read)

data AddOp = Plus | Minus
  deriving (Eq, Ord, Show, Read)

data MulOp = Times | Div
  deriving (Eq, Ord, Show, Read)

data RelOp = LTH | LE | GTH | GE | EQU | NE
  deriving (Eq, Ord, Show, Read)

data Decl
    = VDecl Ident Ty Expr
    | FDecl Ident [FunArgIdent] Ty Expr
    | DDecl Ident [ConstrArg] [ConstrDef]
  deriving (Eq, Ord, Show, Read)

data FunArgIdent = FunArgIdentT Ident
  deriving (Eq, Ord, Show, Read)

data ConstrDef = Constr Ident [ConstrArg]
  deriving (Eq, Ord, Show, Read)

data ConstrArg = ConstrArgDef Ident
  deriving (Eq, Ord, Show, Read)

data Ty = TVar Ident | TApp Ty Ty | TBool | TInt | TArrow Ty Ty
  deriving (Eq, Ord, Show, Read)

data Bind = BindMulti [BindElem]
  deriving (Eq, Ord, Show, Read)

data BindElem = BindElemT Ident Ty
  deriving (Eq, Ord, Show, Read)

data EAlt = EAltCase ETopPattern Expr
  deriving (Eq, Ord, Show, Read)

data ETopPattern
    = ETopPatternAt Ident EPattern | ETopPatternNo EPattern
  deriving (Eq, Ord, Show, Read)

data EPattern
    = EPatData Ident [EPatConstrArg]
    | EPatBind Bind
    | EPatLit Lit
    | EPatIdent Ident
    | EPatDefault
    | EPatHeadIdent Ident EPattern
    | EPatHeadLit Lit EPattern
  deriving (Eq, Ord, Show, Read)

data EPatConstrArg = EPatConstrArgDef Ident
  deriving (Eq, Ord, Show, Read)

