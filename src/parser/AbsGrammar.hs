

module AbsGrammar where

-- Haskell module generated by the BNF converter




newtype Ident = Ident String deriving (Eq, Ord, Show, Read)
data Prog = Program [Decl]
  deriving (Eq, Ord, Show, Read)

data Lit = LitInt Integer | LitTrue | LitFalse | LitList [Expr]
  deriving (Eq, Ord, Show, Read)

data Expr
    = EVar Ident
    | ELit Lit
    | EApp Expr Expr
    | Neg Expr
    | Not Expr
    | ECons Expr Expr
    | EMul Expr MulOp Expr
    | EAdd Expr AddOp Expr
    | ERel Expr RelOp Expr
    | EAnd Expr Expr
    | EOr Expr Expr
    | Lambda Bind Expr
    | Let [Decl] Expr
    | Case Expr [Alt]
    | If Expr Expr Expr
  deriving (Eq, Ord, Show, Read)

data AddOp = Plus | Minus
  deriving (Eq, Ord, Show, Read)

data MulOp = Times | Div
  deriving (Eq, Ord, Show, Read)

data RelOp = LTH | LE | GTH | GE | EQU | NE
  deriving (Eq, Ord, Show, Read)

data Decl
    = VDecl Ident Ty Expr
    | FDecl Ident [FunArgIdent] Ty Expr
    | DDecl Ident [ConstrArg] [ConstrDef]
  deriving (Eq, Ord, Show, Read)

data FunArgIdent = FunArgIdentT Ident
  deriving (Eq, Ord, Show, Read)

data ConstrDef = Constr Ident [ConstrArg]
  deriving (Eq, Ord, Show, Read)

data ConstrArg = ConstrArgDef Ident
  deriving (Eq, Ord, Show, Read)

data Ty
    = TVar Ident | TList Ty | TApp Ty Ty | TBool | TInt | TArrow Ty Ty
  deriving (Eq, Ord, Show, Read)

data Bind = BindMulti [BindElem]
  deriving (Eq, Ord, Show, Read)

data BindElem = BindElemT Ident Ty
  deriving (Eq, Ord, Show, Read)

data Alt = AltCase TopPattern Expr
  deriving (Eq, Ord, Show, Read)

data TopPattern = TopPatternAt Ident Pattern | TopPatternNo Pattern
  deriving (Eq, Ord, Show, Read)

data Pattern
    = PatData Ident [PatConstrArg]
    | PatBind Bind
    | PatLit Lit
    | PatIdent Ident
    | PatDefault
    | PatHeadIdent Ident Pattern
    | PatHeadLit Lit Pattern
  deriving (Eq, Ord, Show, Read)

data PatConstrArg = PatConstrArgDef Ident
  deriving (Eq, Ord, Show, Read)

